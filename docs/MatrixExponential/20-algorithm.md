# 行列指数関数の数値解析 -実装編-

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [行列指数関数の数値解析 -実装編-](#行列指数関数の数値解析--実装編-)
  - [0. 初めに](#0-初めに)
  - [1. 実装全体の流れ](#1-実装全体の流れ)
  - [2. スケーリング & スクエアリング法との組み合わせ](#2-スケーリング--スクエアリング法との組み合わせ)
  - [3. Padé 近似の準備](#3-padé-近似の準備)
  - [4. 偶奇分解による $V_m, U_m $ の計算](#4-偶奇分解による-v_m-u_m--の計算)
  - [5. 線形方程式の解法（LU分解）](#5-線形方程式の解法lu分解)

<!-- /code_chunk_output -->

## 0. 初めに

「理論編」では Padé 近似の係数公式と偶奇分解を導いた。
実装編ではこれを具体的な計算アルゴリズムに落とし込む。

---

## 1. 実装全体の流れ

Padé近似を用いた行列指数関数 $e^A$ の数値は主に *Padé_expm()* で行われている。
関数内の基本的な流れは以下の通り：

| 手順         | 関数例                                                              | 処理内容                                           |
| ---------- | ---------------------------------------------------------------- | ---------------------------------------------- |
| 1. ノルム評価   | `matrix_norm_1()`| 1-ノルムを計算し、スケーリングが必要か判定する                       |
| 2. スケーリング  | `Padé_choose_scaling_and_order()`, `matrix_scale_down_pow2()` | 適切な次数 m とスケーリング係数 s を選択。大きい場合は A を A/2^s に変換する |
| 3. Padé 近似 | `Padé_exp_get_table()`| Padé 係数を取得し、近似の準備を行う                           |
| 4. 偶奇分解    | `build_UV_for_m()`| Vm, Um を構築する                                   |
| 5. 線形方程式   | `matrix_solve_LU()`| (Vm - Um) X = (Vm + Um) を解き、R\_m(A) を得る        |
| 6. スクエアリング | （行列積の繰り返し）| e^A = (R\_m(A/2^s))^(2^s) を再帰的に2乗して復元する        |

---

## 2. スケーリング & スクエアリング法との組み合わせ

大きな $|A| $ に対してはそのまま近似すると誤差が増えるため、
**スケーリング & スクエアリング法** を組み合わせる：

1. $|A| $ を評価して $s $ を決定
2. $A \to A/2^s $ に縮小
3. Padé 近似で $R_m(A/2^s) $ を計算
4. $2^s $ 回繰り返し2乗して元に戻す (手順6)

---

## 3. Padé 近似の準備

次数 $m $ を選び、公式

$$
c_j^{(m)} = \frac{(2m-j)!\,m!}{(2m)!\,j!\,(m-j)!}, \quad j=0,\dots,m
\tag{1}
$$

で係数を事前に計算しておく。
これらは固定の係数表として`Padé_exp_coeffs.c`に定義している。

> **補足：MATLAB/Highamでの係数表現**  
MATLAB/HighamではPadé近似の係数$c_j$をそのまま用いておらず、スケーリングした$b_j$を使用している。
$$
P_m(x) = \sum_{j=0}^m b_j\,x^j \\
b_j = c_j^{(m)} \cdot \frac{(2m)!}{m!}
$$
このスケール因子 $\frac{(2m)!}{m!}$ は、**分母と分子の両方に同じ定数倍を掛けた**だけである。  
有理関数 \(R_m(x) = P_m(x)/Q_m(x)\) の値は、分子と分母に同じ定数倍をしても変わらないので、近似自体は同じである。
スケーリングを行う実装的な理由は次の通り。
**整数係数にできる**  
  このスケーリングをすると \(b_j\) がきれいな整数になりやすい（120, 60, 12, … のように）。  
  定数としてハードコードしやすく、丸め誤差も抑えられる。
**冪乗計算での安定性改善**  
  \(b_j\) が極端に小さい値や分数だと、行列累乗の加算時に桁落ちしやすいが、適度に大きい整数にしておくと相対誤差が減る。
**既存実装との互換性**  
  Higham の `expm` 実装や古い Fortran 系実装では、この整数形式が広く用いられている。

---

## 4. 偶奇分解による $V_m, U_m $ の計算

係数を使って $V_m, U_m $ を作る：

* 偶数次項

$$
V_m = c_0 I + c_2 A^2 + c_4 A^4 + \cdots
\tag{2}
$$

* 奇数次項

$$
U_m = c_1 A + c_3 A^3 + \cdots
\tag{3}
$$

ここでは **行列累乗の繰り返し計算** が必要になるため、
効率化のためには $A^2, A^3, \dots, A^m $ を逐次計算して再利用する。

---

## 5. 線形方程式の解法（LU分解）

Padé 近似の形は

$$
R_m(A) = (V_m+U_m)(V_m-U_m)^{-1}
\tag{4}
$$

となる。

数値解析では、これを逆行列を直接計算せずに **LU分解による線形方程式** を解くのが定石である。

$$
(V_m - U_m) X = (V_m + U_m)
$$

を解くことで $X = R_m(A)$ が得られる。
ここで用いる関数が **matrix\_solve\_LU()** であり、内部的には以下の流れになる：

1. $V_m - U_m$ を LU 分解する
2. 前進代入・後退代入を行い、$X$ を求める

この方法により **数値安定性を確保**しつつ、逆行列計算を避けられる。

---





